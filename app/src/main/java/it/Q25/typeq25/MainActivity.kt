package it.srik.TypeQ25

import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.os.Build
import android.os.Bundle
import android.provider.Settings
import android.view.KeyEvent
import android.view.inputmethod.InputMethodManager
import androidx.activity.ComponentActivity
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.animation.*
import androidx.compose.animation.core.tween
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.size
import it.srik.TypeQ25.R
import it.srik.TypeQ25.inputmethod.KeyboardEventTracker
import it.srik.TypeQ25.inputmethod.NotificationHelper
import it.srik.TypeQ25.ui.CustomTopBar
import it.srik.TypeQ25.ui.theme.TypeQ25Theme
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowForward
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material.icons.filled.Warning
import androidx.compose.material.icons.filled.Keyboard
import androidx.activity.compose.BackHandler
import kotlinx.coroutines.delay

class MainActivity : ComponentActivity() {
    
    data class KeyEventInfo(
        val keyCode: Int,
        val keyCodeName: String,
        val action: String,
        val unicodeChar: Int,
        val isAltPressed: Boolean,
        val isShiftPressed: Boolean,
        val isCtrlPressed: Boolean
    )
    
    override fun onKeyDown(keyCode: Int, event: KeyEvent?): Boolean {
        // Notify only events that are not output keycodes generated by the service.
        // Output keycodes (DPAD, TAB, PAGE_UP, PAGE_DOWN, ESCAPE) without modifiers
        // are generated by the service and the original event with output has already been reported.
        if (event != null) {
            val isOutputKeyCode = keyCode in listOf(
                KeyEvent.KEYCODE_DPAD_UP,
                KeyEvent.KEYCODE_DPAD_DOWN,
                KeyEvent.KEYCODE_DPAD_LEFT,
                KeyEvent.KEYCODE_DPAD_RIGHT,
                KeyEvent.KEYCODE_TAB,
                KeyEvent.KEYCODE_PAGE_UP,
                KeyEvent.KEYCODE_PAGE_DOWN,
                KeyEvent.KEYCODE_ESCAPE
            )
            val hasModifiers = event.isAltPressed || event.isShiftPressed || event.isCtrlPressed
            
            // Ignora i keycode di output senza modificatori (sono generati dal servizio)
            if (!isOutputKeyCode || hasModifiers) {
                KeyboardEventTracker.notifyKeyEvent(keyCode, event, "KEY_DOWN")
            }
        }
        return super.onKeyDown(keyCode, event)
    }
    
    override fun onKeyUp(keyCode: Int, event: KeyEvent?): Boolean {
        // Notify only events that are not output keycodes generated by the service.
        if (event != null) {
            val isOutputKeyCode = keyCode in listOf(
                KeyEvent.KEYCODE_DPAD_UP,
                KeyEvent.KEYCODE_DPAD_DOWN,
                KeyEvent.KEYCODE_DPAD_LEFT,
                KeyEvent.KEYCODE_DPAD_RIGHT,
                KeyEvent.KEYCODE_TAB,
                KeyEvent.KEYCODE_PAGE_UP,
                KeyEvent.KEYCODE_PAGE_DOWN,
                KeyEvent.KEYCODE_ESCAPE
            )
            val hasModifiers = event.isAltPressed || event.isShiftPressed || event.isCtrlPressed
            
            // Ignore output keycodes without modifiers (they are generated by the service)
            if (!isOutputKeyCode || hasModifiers) {
                KeyboardEventTracker.notifyKeyEvent(keyCode, event, "KEY_UP")
            }
        }
        return super.onKeyUp(keyCode, event)
    }
    
    private fun getKeyCodeName(keyCode: Int): String {
        return when (keyCode) {
            KeyEvent.KEYCODE_Q -> "KEYCODE_Q"
            KeyEvent.KEYCODE_W -> "KEYCODE_W"
            KeyEvent.KEYCODE_E -> "KEYCODE_E"
            KeyEvent.KEYCODE_R -> "KEYCODE_R"
            KeyEvent.KEYCODE_T -> "KEYCODE_T"
            KeyEvent.KEYCODE_Y -> "KEYCODE_Y"
            KeyEvent.KEYCODE_U -> "KEYCODE_U"
            KeyEvent.KEYCODE_I -> "KEYCODE_I"
            KeyEvent.KEYCODE_O -> "KEYCODE_O"
            KeyEvent.KEYCODE_P -> "KEYCODE_P"
            KeyEvent.KEYCODE_A -> "KEYCODE_A"
            KeyEvent.KEYCODE_S -> "KEYCODE_S"
            KeyEvent.KEYCODE_D -> "KEYCODE_D"
            KeyEvent.KEYCODE_F -> "KEYCODE_F"
            KeyEvent.KEYCODE_G -> "KEYCODE_G"
            KeyEvent.KEYCODE_H -> "KEYCODE_H"
            KeyEvent.KEYCODE_J -> "KEYCODE_J"
            KeyEvent.KEYCODE_K -> "KEYCODE_K"
            KeyEvent.KEYCODE_L -> "KEYCODE_L"
            KeyEvent.KEYCODE_Z -> "KEYCODE_Z"
            KeyEvent.KEYCODE_X -> "KEYCODE_X"
            KeyEvent.KEYCODE_C -> "KEYCODE_C"
            KeyEvent.KEYCODE_V -> "KEYCODE_V"
            KeyEvent.KEYCODE_B -> "KEYCODE_B"
            KeyEvent.KEYCODE_N -> "KEYCODE_N"
            KeyEvent.KEYCODE_M -> "KEYCODE_M"
            KeyEvent.KEYCODE_SPACE -> "KEYCODE_SPACE"
            KeyEvent.KEYCODE_ENTER -> "KEYCODE_ENTER"
            KeyEvent.KEYCODE_DEL -> "KEYCODE_DEL"
            KeyEvent.KEYCODE_BACK -> "KEYCODE_BACK"
            else -> "KEYCODE_$keyCode"
        }
    }
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        
        // Check if tutorial should be shown on first launch
        if (!SettingsManager.isTutorialCompleted(this)) {
            val intent = Intent(this, TutorialActivity::class.java)
            startActivity(intent)
        }
        
        setContent {
            TypeQ25Theme {
                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding ->
                    KeyboardSetupScreen(
                        modifier = Modifier
                            .padding(innerPadding)
                            .fillMaxSize(),
                        activity = this@MainActivity
                    )
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DeviceSelectionDialog(onDeviceSelected: (String) -> Unit, onDismiss: () -> Unit) {
    val devices = listOf("Q25", "titan2")
    var expanded by remember { mutableStateOf(false) }
    var selectedDevice by remember { mutableStateOf(devices[0]) }

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Select Your Device") },
        text = {
            Column {
                Text("Please select your device to apply the correct key mappings.")
                Spacer(modifier = Modifier.height(16.dp))
                ExposedDropdownMenuBox(
                    expanded = expanded,
                    onExpandedChange = { expanded = !expanded }
                ) {
                    TextField(
                        modifier = Modifier.menuAnchor(),
                        readOnly = true,
                        value = selectedDevice,
                        onValueChange = {},
                        label = { Text("Device") },
                        trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded) },
                        colors = ExposedDropdownMenuDefaults.textFieldColors(),
                    )
                    ExposedDropdownMenu(
                        expanded = expanded,
                        onDismissRequest = { expanded = false },
                    ) {
                        devices.forEach { device ->
                            DropdownMenuItem(
                                text = { Text(device) },
                                onClick = {
                                    selectedDevice = device
                                    expanded = false
                                }
                            )
                        }
                    }
                }
            }
        },
        confirmButton = {
            Button(onClick = { onDeviceSelected(selectedDevice) }) {
                Text("Save")
            }
        }
    )
}

@Composable
fun KeyboardSetupScreen(
    modifier: Modifier = Modifier,
    activity: MainActivity
) {
    val context = LocalContext.current
    var showDeviceSelectionDialog by remember { mutableStateOf(false) }

    LaunchedEffect(Unit) {
        if (!DeviceManager.isDeviceSelected(context)) {
            showDeviceSelectionDialog = true
        }
    }

    if (showDeviceSelectionDialog) {
        DeviceSelectionDialog(
            onDeviceSelected = {
                DeviceManager.setDevice(context, it)
                showDeviceSelectionDialog = false
            },
            onDismiss = { showDeviceSelectionDialog = false }
        )
    }
    
    var testText by remember { mutableStateOf("") }
    val lastKeyEventState = remember { mutableStateOf<KeyboardEventTracker.KeyEventInfo?>(null) }
    val lastKeyEvent by lastKeyEventState
    
    // State for IME status
    var isTypeQ25Enabled by remember { mutableStateOf(false) }
    var isTypeQ25Selected by remember { mutableStateOf(false) }
    
    // Check IME status
    LaunchedEffect(Unit) {
        checkImeStatus(context) { enabled, selected ->
            isTypeQ25Enabled = enabled
            isTypeQ25Selected = selected
        }
    }
    
    // Refresh IME status periodically and when activity resumes
    LaunchedEffect(Unit) {
        // Check status every 2 seconds when screen is visible
        while (true) {
            kotlinx.coroutines.delay(2000)
            checkImeStatus(context) { enabled, selected ->
                isTypeQ25Enabled = enabled
                isTypeQ25Selected = selected
            }
        }
    }
    
    // Request notification permission (Android 13+)
    val requestPermissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestPermission()
    ) { isGranted: Boolean ->
        if (isGranted) {
            android.util.Log.d("MainActivity", "Notification permission granted")
        } else {
            android.util.Log.w("MainActivity", "Notification permission denied")
        }
    }
    
    // Request notification permission when the composable is created (Android 13+ only)
    LaunchedEffect(Unit) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (!NotificationHelper.hasNotificationPermission(context)) {
                requestPermissionLauncher.launch(android.Manifest.permission.POST_NOTIFICATIONS)
            }
        }
    }
    
    // Connect state to the global tracker
    LaunchedEffect(Unit) {
        KeyboardEventTracker.registerState(lastKeyEventState)
    }
    
    // Clear state when the composable is removed
    DisposableEffect(Unit) {
        onDispose {
            KeyboardEventTracker.unregisterState()
        }
    }
    
    // Main screen
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .verticalScroll(rememberScrollState()),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        // Custom top bar with personalized graphics
        CustomTopBar(
            onSettingsClick = {
                val settingsIntent = Intent(context, SettingsActivity::class.java)
                context.startActivity(settingsIntent)
            },
            modifier = Modifier.fillMaxWidth()
        )
        
        // Enable TypeQ25 button
        Surface(
            modifier = Modifier
                .fillMaxWidth()
                .clickable {
                    val intent = Intent(Settings.ACTION_INPUT_METHOD_SETTINGS)
                    context.startActivity(intent)
                }
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.spacedBy(12.dp),
                        modifier = Modifier.weight(1f)
                    ) {
                        Icon(
                            imageVector = Icons.Filled.Keyboard,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.primary
                        )
                        Text(
                            text = stringResource(R.string.enable_TypeQ25),
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Medium
                        )
                    }
                    if (!isTypeQ25Enabled) {
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.spacedBy(4.dp)
                        ) {
                            Icon(
                                imageVector = Icons.Filled.Warning,
                                contentDescription = null,
                                tint = MaterialTheme.colorScheme.error,
                                modifier = Modifier.size(20.dp)
                            )
                            Text(
                                text = stringResource(R.string.TypeQ25_not_enabled),
                                style = MaterialTheme.typography.bodySmall,
                                color = MaterialTheme.colorScheme.error
                            )
                        }
                    } else {
                        Icon(
                            imageVector = Icons.Filled.ArrowForward,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }
            }
        }
        
        // Choose input method button
        Surface(
            modifier = Modifier
                .fillMaxWidth()
                .clickable {
                    val imm = context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
                    imm.showInputMethodPicker()
                }
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.spacedBy(12.dp),
                        modifier = Modifier.weight(1f)
                    ) {
                        Icon(
                            imageVector = Icons.Filled.Keyboard,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.primary
                        )
                        Text(
                            text = stringResource(R.string.choose_input_method),
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Medium
                        )
                    }
                    if (isTypeQ25Enabled && !isTypeQ25Selected) {
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.spacedBy(4.dp)
                        ) {
                            Icon(
                                imageVector = Icons.Filled.Warning,
                                contentDescription = null,
                                tint = MaterialTheme.colorScheme.error,
                                modifier = Modifier.size(20.dp)
                            )
                            Text(
                                text = stringResource(R.string.TypeQ25_not_selected),
                                style = MaterialTheme.typography.bodySmall,
                                color = MaterialTheme.colorScheme.error
                            )
                        }
                    } else {
                        Icon(
                            imageVector = Icons.Filled.ArrowForward,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }
            }
        }
        
        // Test field
        OutlinedTextField(
            value = testText,
            onValueChange = { testText = it },
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp),
            placeholder = { Text(stringResource(R.string.test_field_placeholder)) },
            minLines = 2,
            maxLines = 5
        )
        
        // Last keyboard event (only if present)
        val event = lastKeyEvent
        if (event != null) {
            Surface(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp)
            ) {
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Text(
                        text = stringResource(R.string.last_keyboard_event_title),
                        style = MaterialTheme.typography.titleSmall,
                        fontWeight = FontWeight.Medium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Text(
                        text = "${event.keyCodeName}",
                        style = MaterialTheme.typography.bodyMedium,
                        fontFamily = FontFamily.Monospace
                    )
                    Text(
                        text = "${stringResource(R.string.event_unicode_label)}${event.unicodeChar} (${if (event.unicodeChar != 0) event.unicodeChar.toChar() else stringResource(R.string.event_not_available)})",
                        style = MaterialTheme.typography.bodyMedium,
                        fontFamily = FontFamily.Monospace
                    )
                    if (event.outputKeyCodeName != null) {
                        Text(
                            text = "${stringResource(R.string.event_output_label)}${event.outputKeyCodeName}${if (event.outputKeyCode != null) " (${event.outputKeyCode})" else ""}",
                            style = MaterialTheme.typography.bodyMedium,
                            fontFamily = FontFamily.Monospace,
                            color = MaterialTheme.colorScheme.primary
                        )
                    }
                    if (event.isShiftPressed || event.isCtrlPressed || event.isAltPressed) {
                        Row(
                            horizontalArrangement = Arrangement.spacedBy(4.dp)
                        ) {
                            if (event.isShiftPressed) {
                                Surface(
                                    color = MaterialTheme.colorScheme.primaryContainer,
                                    shape = MaterialTheme.shapes.small
                                ) {
                                    Text(
                                        text = stringResource(R.string.modifier_shift),
                                        style = MaterialTheme.typography.labelSmall,
                                        modifier = Modifier.padding(horizontal = 6.dp, vertical = 2.dp),
                                        fontWeight = FontWeight.Medium
                                    )
                                }
                            }
                            if (event.isCtrlPressed) {
                                Surface(
                                    color = MaterialTheme.colorScheme.primaryContainer,
                                    shape = MaterialTheme.shapes.small
                                ) {
                                    Text(
                                        text = stringResource(R.string.modifier_ctrl),
                                        style = MaterialTheme.typography.labelSmall,
                                        modifier = Modifier.padding(horizontal = 6.dp, vertical = 2.dp),
                                        fontWeight = FontWeight.Medium
                                    )
                                }
                            }
                            if (event.isAltPressed) {
                                Surface(
                                    color = MaterialTheme.colorScheme.primaryContainer,
                                    shape = MaterialTheme.shapes.small
                                ) {
                                    Text(
                                        text = stringResource(R.string.modifier_alt),
                                        style = MaterialTheme.typography.labelSmall,
                                        modifier = Modifier.padding(horizontal = 6.dp, vertical = 2.dp),
                                        fontWeight = FontWeight.Medium
                                    )
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

/**
 * Checks if TypeQ25 IME is enabled and selected.
 * Uses InputMethodManager for Android 14+ compatibility.
 */
private fun checkImeStatus(
    context: Context,
    callback: (enabled: Boolean, selected: Boolean) -> Unit
) {
    try {
        val imm = context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
        val TypeQ25PackageName = "it.srik.TypeQ25"
        val TypeQ25ImeId = "it.srik.TypeQ25/.inputmethod.PhysicalKeyboardInputMethodService"
        
        // Check if TypeQ25 is enabled using InputMethodManager
        val enabledInputMethods = imm.enabledInputMethodList
        val isEnabled = enabledInputMethods.any { inputMethodInfo ->
            inputMethodInfo.packageName == TypeQ25PackageName ||
            inputMethodInfo.id == TypeQ25ImeId
        }
        
        // Check if TypeQ25 is selected
        var isSelected = false
        if (isEnabled) {
            // Try to read DEFAULT_INPUT_METHOD
            // On Android 13 (API 33) it might still work even with targetSdk 36
            // On Android 14+ (API 34+) it will throw SecurityException
            try {
                val defaultInputMethod = android.provider.Settings.Secure.getString(
                    context.contentResolver,
                    android.provider.Settings.Secure.DEFAULT_INPUT_METHOD
                ) ?: ""
                isSelected = defaultInputMethod == TypeQ25ImeId
            } catch (e: SecurityException) {
                // On Android 14+ (API 34+) with targetSdk 36, we can't read this setting
                // Try alternative method: check if we can get current input method info
                try {
                    // Alternative: check if our IME is in the list and try to infer selection
                    // This is not 100% reliable, but it's the best we can do
                    val currentSubtype = imm.currentInputMethodSubtype
                    if (currentSubtype != null) {
                        // If we have a subtype, check if it matches our package
                        // Note: This is a heuristic and may not be 100% accurate
                        val allInputMethods = imm.inputMethodList
                        val TypeQ25InputMethod = allInputMethods.find { 
                            it.packageName == TypeQ25PackageName || it.id == TypeQ25ImeId 
                        }
                        // If TypeQ25 is the only enabled IME, assume it's selected
                        if (TypeQ25InputMethod != null && enabledInputMethods.size == 1) {
                            isSelected = true
                        } else {
                            // We can't reliably determine, so assume not selected to show warning
                            isSelected = false
                        }
                    } else {
                        // Can't determine, assume not selected
                        isSelected = false
                    }
                } catch (e2: Exception) {
                    // If all methods fail, assume not selected
                    isSelected = false
                }
            } catch (e: Exception) {
                // Other exceptions, assume not selected
                isSelected = false
            }
        }
        
        callback(isEnabled, isSelected)
    } catch (e: Exception) {
        android.util.Log.e("MainActivity", "Error checking IME status", e)
        callback(false, false)
    }
}